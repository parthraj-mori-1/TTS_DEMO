<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WebSocket Chat + Audio</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #chat { border: 1px solid #ccc; padding: 10px; height: 300px; overflow-y: auto; margin-bottom: 10px; }
    .message { margin: 5px 0; }
    .user { color: blue; }
    .server { color: green; }
  </style>
</head>
<body>
  <h2>Chat + Audio Player</h2>
  <div id="chat"></div>
  <input type="text" id="messageInput" placeholder="Type a message" />
  <button id="sendBtn">Send</button>

  <script>
    const ws = new WebSocket("wss://r1iwk0c5l6.execute-api.ap-south-1.amazonaws.com/dev"); // <-- replace
    ws.binaryType = "arraybuffer";

    const chat = document.getElementById("chat");
    const input = document.getElementById("messageInput");
    const sendBtn = document.getElementById("sendBtn");

    let audioCtx;
    let workletNode;

    function appendMessage(msg, cls) {
      const div = document.createElement("div");
      div.className = "message " + cls;
      div.textContent = msg;
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }

    ws.onopen = () => {
      appendMessage("âœ… Connected to server", "server");
    };

    ws.onmessage = (ev) => {
  if (typeof ev.data === "string") {
    try {
      const parsed = JSON.parse(ev.data);

      switch (parsed.type) {
        case "text":
          appendMessage(parsed.text, "server");
          break;

        case "audio_start":
          console.log("ðŸ”Š Audio stream started");
          // you could reset buffers here if needed
          break;

        case "audio_end":
          console.log("ðŸ”Š Audio stream ended");
          // optional: signal UI that playback is done
          break;

        default:
          console.warn("Unknown message type:", parsed);
      }
    } catch {
      console.warn("Unexpected non-JSON text from server:", ev.data);
    }
    return;
  }

  // ----- Binary PCM audio -----
  if (ev.data instanceof ArrayBuffer) {
    const pcm16 = new Int16Array(ev.data);
    const float32 = new Float32Array(pcm16.length);

    for (let i = 0; i < pcm16.length; i++) {
      float32[i] = pcm16[i] / 32768.0; // normalize
    }

    if (workletNode) {
      workletNode.port.postMessage({ samples: float32 });
    }
  }
};


    sendBtn.onclick = () => {
      const message = input.value.trim();
      if (!message) return;
      appendMessage(message, "user");
      ws.send(JSON.stringify({ action: "sendMessage", message }));
      input.value = "";
    };

    async function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      await audioCtx.audioWorklet.addModule(URL.createObjectURL(new Blob([`
        class PCMPlayer extends AudioWorkletProcessor {
          constructor() {
            super();
            this.buffer = [];
            this.port.onmessage = (e) => {
              if (e.data.samples) {
                this.buffer.push(...e.data.samples);
              }
            };
          }
          process(inputs, outputs) {
            const output = outputs[0][0];
            for (let i = 0; i < output.length; i++) {
              output[i] = this.buffer.length > 0 ? this.buffer.shift() : 0;
            }
            return true;
          }
        }
        registerProcessor('pcm-player', PCMPlayer);
      `], { type: "application/javascript" })));

      workletNode = new AudioWorkletNode(audioCtx, "pcm-player");
      workletNode.connect(audioCtx.destination);
    }

    initAudio();
  </script>
</body>
</html>

